
## Сувеніри
У файловому сховищі (набір файлів довільної структури) знаходиться
інформація про сувеніри та їх виробників.
### Для сувенірів необхідно зберігати:
- назву;
- реквізити виробника;
- дату випуску;
- ціну.
### Для виробників необхідно зберігати:
- назву;
- країну.
### Реалізувати такі можливості:
- Додавати, редагувати, переглядати всіх виробників та всі сувеніри.
- Вивести інформацію про сувеніри заданого виробника.
- Вивести інформацію про сувеніри, виготовлені в заданій країні.
- Вивести інформацію про виробників, чиї ціни на сувеніри менше заданої.
- Вивести інформацію по всіх виробниках та, для кожного виробника вивести інформацію
про всі сувеніри, які він виробляє.
- Вивести інформацію про виробників заданого сувеніру, виробленого у заданому року.
- Для кожного року вивести список сувенірів, зроблених цього року.
- Видалити заданого виробника та його сувеніри.


    P.S. Бази даних не використовуємо (тільки файли).

Для зберігання даних у програмі використовуємо колекції. У процесі обробки
використовуємо Streams (або не використовуємо, якщо простіше без них)

    Примітка. У різних виробників може бути сувеніри з однаковими назвами. Наприклад, сувенір “Фірмова чашка” 
    може бути у виробників “Національний університет кораблебудування” та “Приватбанк”.




### Вирішення

#### Зберігання об'єктів
Дані зберігаються у файловій системі у форматі JSON. Для роботи над JSON використовуються біблітека Jackson.
За замовчуванням як каталог для зберігання зазначається ***src\main\resources\data***. 
Для зміни каталогу зберігання: в інтерфейсі ***StorageProperties***  що знаходиться за адресою
***src\main\java\gfl\havryliuk\storage*** слід зазначети власний каталог. 

Для додавання нового каталогу реалізувати власний ***FileStorage*** в якому зазначити ім'я файлу з розширенням .json.
Основні операції над файлами-документами виконує клас ***Document*** якому делегується робота над створенням файлів, 
зберіганням документів або ж читанням записів. Власне обхід вузлів JSON та їх редакування виконується в репозиторії
***Repository***.

Кожен об'єкт зберігається в окремому файлі . Посилання об'єктів один на одного здійснюється через id. Наприклад:
    
    Виробники:
    [
        {
            "id": "ba4f973f-11fe-4b6a-bab0-dd842c6037a1",
            "name": "Producer 01",
            "country": "Country 01",
                "souvenirs": [
                  {
                    "id": "a25babb3-e114-44e1-8987-99b8c876833a"
                  },
                  {
                    "id": "e155e213-6848-4b10-93ef-8f6cbbbb00d4"
                  }
            ]
        }
    ]

    Сувеніри:
    [
        {
        "id": "a25babb3-e114-44e1-8987-99b8c876833a",
        "name": "Tea cup",
        "price": 11.05,
        "productionDate": "2014-12-20T02:30:00",
            "producer": {
                "id": "ba4f973f-11fe-4b6a-bab0-dd842c6037a1"
            }
        },
        {
        "id": "e155e213-6848-4b10-93ef-8f6cbbbb00d4",
        "name": "Coffee cup",
        "price": 14.00,
        "productionDate": "2014-12-20T02:30:00",
            "producer": {
                "id": "ba4f973f-11fe-4b6a-bab0-dd842c6037a1"
            }
        }
    ]

Додавання нового сувеніра чи виробника: якщо об'єкт в файлах не існує він додається, а якщо він з таким ID вже наявний -
відповідно відбувається його заміна.

#### Представлення об'єктів
При вибірці виробників та сувенірів, репозиторій повертає не повноцінний об'єкт. Наприклад, у виробників
в списку сувенірів будуть зазначатись лише їх ID, а в сувенірів у виробника буде вказаний лише ID.
Більшість запитів з умови задачі це задовільняє, а для умови *"Вивести інформацію по всіх виробниках та, для кожного
виробника вивести інформацію про всі сувеніри, які він виробляє"* репозиторій ініціалізує виробників повноцінним
списком сувенірів.


#### Патерни
Pattern "Strategy" - в класі Document<T>, в залежності від реалізації інтерфейсу Storage, на запит getStorage()
повертаєтся конкретний файл для зберігання конкретного об'єкту.

Pattern "Singleton" - об'єкт Mapper, який розширює ObjectMapper бібліотеки Jackson. Згідно її документації на
створенян ObjectMapper виліляються значні ресурси, тому Mapper один на цілу програму. 



#### Композиція
Об'єкт Souvenir не може існувати без об'єкту Producer. При видаленні Producer видаляються і його Souvenir.

#### Consistency
- при створенні: Спочатку необхідно зберегти виробника, а потім сувенір. При збереженні сувеніру, якщо ID виробника 
  в файлі виробників не буде, репозиторій видасть IllegalStateException() з відповідним повідомленям, та ID не 
  збереженого виробника. Те ж буде якщо намагатись зберегти кілька сувенірів відразу (в повідомленні про відсутність 
  з Id зазначиться лише один). Якщо зберігати виробника - його сувеніри, при наявності, зберігаються автоматично.
- при видаленні: При видаленні Souvenir (одного або ж кількох відразу), репозиторій забезпечує видалення як сувеніру
  (сувенірів) з файлу Souvenir, так і видалення відповідних їм ID з файлу Producer. Відповідно, видаленні Producer
  видаляються всі сувеніри з обох файлів.


#### Тестування
Для тестів використовуються окремі файлові сховища. Основний "репозиторій" замінюється під час тестування
за допомогою ***Mockito***. Як наслідок - тестування виконувати безпечно при наявності записів у файлах.
Примітка: ініціалізатори об'єктів для тестових випадків написані ..

#### Багатопоточність. Одночасні запити
Програма не разрахована на роботу з багатопоточністю. Всі Singleton не синхронізовані. 

TODO Протестувати на блокування файлів JSON при читанні/запису у них з різних потоків. Для інтересу) 



    Примітка на примітку. У різних виробників може бути сувеніри з однаковими назвами. Наприклад, сувенір “Фірмова чашка” 
    може бути у виробників “Національний університет кораблебудування” та “Приватбанк”.

    Можна було б використати абстрактру фабрику. Але тоді для додавання виробника довелося б створити клас фабрики та
    класи конкретинх продуктів. Тому було прийнято рішення ...